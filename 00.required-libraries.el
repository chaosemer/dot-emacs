;; A better defmacro.
(defmacro defmacro+ (name args &rest body)
  "Like `defmacro*', but also attempts to figure out the indenting"
  (let ((body-index (position-if (lambda (arg) (member arg '(&body &rest)))
                                 (remove '&optional args))))
    `(progn
       (setf (get ',name 'lisp-indent-function) ,body-index)
       (defmacro* ,name ,args ,@body))))
(setf find-function-regexp
      "^\\s-*(\\(def\\(ine-skeleton\\|ine-generic-mode\\|ine-derived-mode\\|ine\\(?:-global\\)?-minor-mode\\|ine-compilation-mode\\|un-cvs-mode\\|foo\\|[^cfgv]\\w+\\*?\\+?\\)\\|easy-mmode-define-[a-z-]+\\|easy-menu-define\\|menu-bar-make-toggle\\)\\(?:\\s-\\|\n\\|;.*\n\\)+\\('\\|(quote \\)?%s\\(\\s-\\|$\\|(\\|)\\)")

;; A more useable user-level way to add hooks.
(defvar hook-minor-mode-*hooks* (make-hash-table :test #'eq))
(defun hook-minor-mode-attach (hook function)
  (when (gethash hook hook-minor-mode-*hooks*)
    (remove-hook hook (gethash hook hook-minor-mode-*hooks*)))
  (add-hook hook function)
  (setf (gethash hook hook-minor-mode-*hooks*) function))

(defmacro+ hook-minor-mode (hook &body modes)
  "Hook each minor mode MODE on HOOK."
  (let ((body (loop for expr in modes
                    if (and (symbolp expr) (fboundp expr))
                      collect (list expr 1)
                    else if (listp expr)
                      collect expr
                    else do (error "~A does not appear to name a minor mode."))))
    `(hook-minor-mode-attach ',hook (lambda () "Auto-generated by `hook-minor-mode'"
                                      ,@body))))

;; Convenient shorthand for requiring without an error.
(defun require-noerror (feature &optional filename)
  (require feature filename t))

;; Patches for buggy/old emacs code:
(unless (fboundp 'warn)
  (message "Using old compatibility mode for `warn'")
  (defalias 'warn 'message))
(unless (fboundp 'cua-mode)
  (require 'cua)
  (warn "Using old compatibility mode for `cua-mode'")
  (defalias 'cua-mode 'CUA-mode))
(unless (fboundp 'grep-tree)
  (warn "Using old compatibility mode for `grep-tree'")
  (defalias 'grep-tree 'grep-find))
(unless (fboundp 'global-semantic-idle-completions-mode)
  (warn "Using old compatibility mode for `global-semantic-idle-completions-mode'")
  (defalias 'global-semantic-idle-completions-mode 'global-semantic-idle-scheduler-mode))
(unless (fboundp 'semantic-default-elisp-setup)
  (warn "Using non-existant function `semantic-default-elisp-setup'")
  (defun semantic-default-elisp-setup ()))
(unless (fboundp 'x-show-tip)
  (warn "Modifying `tooltip-mode' to do nothing or error.")
  (defun tooltip-mode (&optional arg)
    (interactive (list (prefix-numeric-value current-prefix-arg)))
    (when (> arg 0)
      (error "Sorry, tooltips are not yet available on this system"))))
(unless (fboundp 'custom-autoload)
  (warn "Using old compatibility mode for `custom-autoload'")
  (defalias 'custom-autoload 'custom-add-load))
(let ((move-fns '(backward-sexp forward-sexp backward-up-list up-list down-list
                  c-forward-conditional c-backward-conditional
                  c-down-conditional c-up-conditional
                  c-down-conditional-with-else
                  c-up-conditional-with-else)))
  (unless (every (lambda (symbol) (eq 'move (get symbol 'CUA)))
                 move-fns)
    (warn "Adding CUA property to all symbols that need it.")
    (dolist (symbol move-fns)
      (setf (get symbol 'CUA) 'move))))
(unless (fboundp 'semantic-complete-jump-other-window)
  (warn "Creating missing function `semantic-complete-jump-other-window")
  (defun semantic-complete-jump-other-window ()
    "Jump to a semantic symbol."
    (interactive)
    (let* ((semanticdb-search-system-databases nil)
           (tag (semantic-complete-read-tag-project "Symbol: ")))
      (when (semantic-tag-p tag)
        (push-mark)
        (semantic-go-to-tag tag)
        (switch-to-buffer-other-window (current-buffer))
        (semantic-momentary-highlight-tag tag)
        (working-message "%S: %s "
                         (semantic-tag-class tag)
                         (semantic-tag-name  tag))))))
(unless (fboundp 'semantic-complete-jump-other-frame)
  (defun semantic-complete-jump-other-frame ()
    "Jump to a semantic symbol."
    (interactive)
    (let* ((semanticdb-search-system-databases nil)
           (tag (semantic-complete-read-tag-project "Symbol: ")))
      (when (semantic-tag-p tag)
        (push-mark)
        (semantic-go-to-tag tag)
        (switch-to-buffer-other-frame (current-buffer))
        (semantic-momentary-highlight-tag tag)
        (working-message "%S: %s "
                         (semantic-tag-class tag)
                         (semantic-tag-name  tag))))))
(progn
  (warn "Updating `semantic-show-parser-state-marker' to be more GUItiful.")
  ;; Update semantic-show-parser-state-marker
  (require 'semantic-util-modes)
  (setf (get 'semantic-show-parser-state-string 'risky-local-variable) t)
  (defun semantic-show-parser-state-marker (&rest ignore)
    "Set `semantic-show-parser-state-string' to indicate parser state.
This marker is one of the following:
 `-'  ->  The cache is up to date.
 `!'  ->  The cache requires a full update.
 `~'  ->  The cache needs to be incrementally parsed.
 `%'  ->  The cache is not currently parseable.
 `@'  ->  Auto-parse in progress (not set here.)
Arguments IGNORE are ignored, and accepted so this can be used as a hook
in many situations."
    (labels ((make-state-string (string &optional (help-echo "") func)
                                (if func
                                    (let ((map (make-sparse-keymap)))
                                      (setf (lookup-key map (kbd "<mode-line> <mouse-1>")) func)
                                      (propertize string
                                                  'help-echo help-echo
                                                  'mouse-face 'mode-line-highlight
                                                  'local-map map))
                                  (propertize string 'help-echo help-echo))))
      (setf semantic-show-parser-state-string
            (cond ((semantic-parse-tree-needs-rebuild-p) 
                   (make-state-string "!" "Needs a full parse: mouse-1 reparses"
                                      (lambda () (interactive) (semantic-refresh-tags-safe) nil)))
                  ((semantic-parse-tree-needs-update-p)
                   (make-state-string "^" "Needs an incremental parse: mouse-1 reparses"
                                      (lambda () (interactive) (semantic-refresh-tags-safe) nil)))
                  ((semantic-parse-tree-unparseable-p)
                   (make-state-string "%" "Buffer Unparsable: mouse-1 reparses"
                                      (lambda () (interactive) (semantic-refresh-tags-safe) nil)))
                  (t
                   (make-state-string "-" "Semantic is up to date")))
            ))
    ;;(message "Setup mode line indicator to [%s]" semantic-show-parser-state-string)
    (semantic-mode-line-update)))

(defsetf lookup-key define-key)
